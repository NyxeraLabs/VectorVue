"""
Copyright (c) 2026 José María Micoli
Licensed under Apache-2.0

You may:
✔ Study
✔ Modify
✔ Use for internal security testing

You may NOT:
✘ Remove copyright notices
"""

from __future__ import annotations

import sqlite3
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
SQLITE_DB = ROOT / "vectorvue.db"
OUT_FILE = ROOT / "sql" / "postgres_schema.sql"


def qident(name: str) -> str:
    return '"' + name.replace('"', '""') + '"'


def map_type(sqlite_type: str, pk: bool, autoinc: bool) -> str:
    t = (sqlite_type or "TEXT").upper()
    if pk and autoinc:
        return "BIGSERIAL"
    if "INT" in t:
        return "BIGINT"
    if any(x in t for x in ("REAL", "FLOA", "DOUB")):
        return "DOUBLE PRECISION"
    if "BLOB" in t:
        return "BYTEA"
    if "BOOL" in t:
        return "BOOLEAN"
    if any(x in t for x in ("DATE", "TIME")):
        return "TIMESTAMP"
    return "TEXT"


def get_tables(cur):
    cur.execute("SELECT name, sql FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name")
    return cur.fetchall()


def build_schema() -> str:
    conn = sqlite3.connect(SQLITE_DB)
    conn.row_factory = sqlite3.Row
    cur = conn.cursor()

    lines: list[str] = []
    lines.append("-- Auto-generated from vectorvue.db sqlite schema")
    lines.append("-- Generated by scripts/export_pg_schema.py")
    lines.append("SET client_min_messages TO WARNING;")
    lines.append("")

    tables = get_tables(cur)

    fk_constraints: list[str] = []

    for table_row in tables:
        table = table_row["name"]
        create_sql = (table_row["sql"] or "").upper()
        autoinc = "AUTOINCREMENT" in create_sql

        cur.execute(f"PRAGMA table_info({qident(table)})")
        cols = cur.fetchall()
        cur.execute(f"PRAGMA foreign_key_list({qident(table)})")
        fks = cur.fetchall()

        col_defs = []
        pk_cols = []

        for col in cols:
            name = col["name"]
            is_pk = int(col["pk"] or 0) > 0
            if is_pk:
                pk_cols.append(name)
            pg_type = map_type(col["type"], is_pk, autoinc and is_pk)

            default = col["dflt_value"]
            default_sql = ""
            if default is not None and pg_type not in {"BIGSERIAL"}:
                d = str(default).strip()
                if d.upper() == "CURRENT_TIMESTAMP":
                    d = "CURRENT_TIMESTAMP"
                default_sql = f" DEFAULT {d}"

            notnull = " NOT NULL" if int(col["notnull"] or 0) == 1 else ""
            col_defs.append(f"    {qident(name)} {pg_type}{notnull}{default_sql}")

        table_constraints = []
        for fk in fks:
            con_name = f"fk_{table}_{fk['from']}_{fk['table']}_{fk['to']}"
            fk_constraints.append(
                (
                    "DO $$ BEGIN "
                    "IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = {con_name_lit}) THEN "
                    "ALTER TABLE {table} ADD CONSTRAINT {con_name} FOREIGN KEY ({src_col}) REFERENCES {dst_table}({dst_col}); "
                    "END IF; "
                    "END $$;"
                ).format(
                    con_name_lit=repr(con_name),
                    table=qident(table),
                    con_name=qident(con_name),
                    src_col=qident(fk["from"]),
                    dst_table=qident(fk["table"]),
                    dst_col=qident(fk["to"]),
                )
            )

        if pk_cols:
            pk_sql = ", ".join(qident(c) for c in pk_cols)
            table_constraints.insert(0, f"    PRIMARY KEY ({pk_sql})")

        body = ",\n".join(col_defs + table_constraints)
        lines.append(f"CREATE TABLE IF NOT EXISTS {qident(table)} (\n{body}\n);")
        lines.append("")

        # unique constraints via unique indexes
        cur.execute(f"PRAGMA index_list({qident(table)})")
        for idx in cur.fetchall():
            if int(idx["unique"] or 0) != 1:
                continue
            idx_name = idx["name"]
            cur.execute(f"PRAGMA index_info({qident(idx_name)})")
            idx_cols = [qident(r["name"]) for r in cur.fetchall() if r["name"]]
            if idx_cols:
                lines.append(
                    f"CREATE UNIQUE INDEX IF NOT EXISTS {qident(idx_name)} ON {qident(table)} ({', '.join(idx_cols)});"
                )

    # non-unique indexes
    cur.execute("SELECT name, tbl_name, sql FROM sqlite_master WHERE type='index' AND name NOT LIKE 'sqlite_%' ORDER BY name")
    for idx in cur.fetchall():
        if idx["sql"]:
            # best effort reuse with sqlite->postgres tweaks
            stmt = idx["sql"].replace("`", '"').replace("[", '"').replace("]", '"')
            if stmt.upper().startswith("CREATE UNIQUE INDEX"):
                # Unique indexes are already emitted from PRAGMA index_list unique=1.
                continue
            if stmt.upper().startswith("CREATE INDEX "):
                stmt = stmt.replace("CREATE INDEX ", "CREATE INDEX IF NOT EXISTS ", 1)
            lines.append(stmt + ";")
        else:
            # implicit index backing constraints, skip
            continue

    if fk_constraints:
        lines.append("")
        lines.append("-- Foreign keys emitted after all tables to avoid creation-order failures")
        lines.extend(fk_constraints)

    # immutability trigger helpers
    lines.append("")
    lines.append("CREATE OR REPLACE FUNCTION prevent_mutation_when_immutable() RETURNS trigger AS $$")
    lines.append("BEGIN")
    lines.append("    IF OLD.immutable = 1 THEN")
    lines.append("        RAISE EXCEPTION 'immutable row cannot be modified';")
    lines.append("    END IF;")
    lines.append("    RETURN NEW;")
    lines.append("END;")
    lines.append("$$ LANGUAGE plpgsql;")
    lines.append("")
    lines.append("DO $$ BEGIN")
    lines.append("IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='evidence_items' AND column_name='immutable') THEN")
    lines.append("    DROP TRIGGER IF EXISTS trg_evidence_items_immutable_update ON evidence_items;")
    lines.append("    CREATE TRIGGER trg_evidence_items_immutable_update BEFORE UPDATE OR DELETE ON evidence_items")
    lines.append("    FOR EACH ROW EXECUTE FUNCTION prevent_mutation_when_immutable();")
    lines.append("END IF;")
    lines.append("END $$;")

    conn.close()
    return "\n".join(lines) + "\n"


def main() -> int:
    OUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    OUT_FILE.write_text(build_schema(), encoding="utf-8")
    print(f"wrote {OUT_FILE}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
